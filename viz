import json
import os
import glob
import networkx as nx
import matplotlib.pyplot as plt

def select_consolidated_file():
    """Prompt the user to select a consolidated JSON file."""
    files = glob.glob('consolidated_*.json')
    if not files:
        print("No consolidated JSON files found. Please run the validate script first.")
        return None

    print("Available Consolidated JSON Files:")
    for idx, filename in enumerate(files, start=1):
        print(f"{idx}. {filename}")

    while True:
        try:
            choice = int(input("Select a file by entering the corresponding number: "))
            if 1 <= choice <= len(files):
                return files[choice - 1]
            else:
                print(f"Please enter a number between 1 and {len(files)}.")
        except ValueError:
            print("Invalid input. Please enter a number.")

def load_consolidated_data(filename):
    """Load consolidated data from the JSON file."""
    with open(filename, 'r') as f:
        data = json.load(f)
    return data

def visualize_dependencies(consolidated_data):
    """Generate and visualize the dependency graph with grouping per node."""
    # Create a new graph
    G = nx.DiGraph()

    # Keep track of positions for grouping
    positions = {}
    labels = {}

    # Define node colors based on criticality
    criticality_colors = {
        'high': 'red',
        'medium': 'orange',
        'low': 'green',
        'unknown': 'gray'
    }

    # Initialize variables for node grouping
    node_positions = {}  # Map node names to their x positions
    node_x_offsets = {}  # Offset for nodes within each node

    # First, determine positions for each Kubernetes node
    for idx, node_name in enumerate(consolidated_data.keys()):
        node_pos_x = idx * 10  # Adjust the multiplier to control spacing between groups
        node_positions[node_name] = node_pos_x
        node_x_offsets[node_name] = 0  # Start offset for this node

    # Now, add all nodes and edges
    for node_name, reports in consolidated_data.items():
        node_pos_x = node_positions[node_name]
        node_offset = node_x_offsets[node_name]
        node_pos_y = 0

        for report in reports:
            container_full_name = f"{report['namespace']}/{report['container_name']}"
            criticality = report['criticality']
            dependencies = report['dependencies']

            # Add the container as a node if not already added
            if not G.has_node(container_full_name):
                G.add_node(container_full_name, criticality=criticality, node_name=node_name)
                # Assign positions for grouping
                positions[container_full_name] = (node_pos_x + node_offset, node_pos_y)
                node_offset += 1  # Increment offset for next container in the same node
                node_x_offsets[node_name] = node_offset  # Update offset
                # Set labels
                labels[container_full_name] = container_full_name

            # Add edges for dependencies
            for dep in dependencies:
                # Add edge from container to dependency
                G.add_edge(container_full_name, dep)
                # Add dependency node if not already in the graph
                if not G.has_node(dep):
                    G.add_node(dep, external=True)
                    # External dependencies are placed at a fixed position
                    positions[dep] = (node_pos_x + node_offset, node_pos_y - 5)
                    node_offset += 1
                    node_x_offsets[node_name] = node_offset
                    labels[dep] = dep

    # Now assign node colors after all nodes have been added
    node_colors = []
    for node in G.nodes(data=True):
        attrs = node[1]
        if attrs.get('external'):
            node_colors.append('blue')  # External dependencies
        else:
            criticality = attrs.get('criticality', 'unknown')
            node_colors.append(criticality_colors.get(criticality, 'gray'))

    # Draw the graph
    plt.figure(figsize=(14, 10))

    # Draw nodes
    nx.draw_networkx_nodes(G, positions, node_color=node_colors, node_size=500)

    # Draw edges
    nx.draw_networkx_edges(G, positions, arrows=True, arrowstyle='->')

    # Draw labels
    nx.draw_networkx_labels(G, positions, labels=labels, font_size=8)

    # Add legend for criticality
    from matplotlib.patches import Patch
    legend_elements = [
        Patch(facecolor='red', edgecolor='black', label='High Criticality'),
        Patch(facecolor='orange', edgecolor='black', label='Medium Criticality'),
        Patch(facecolor='green', edgecolor='black', label='Low Criticality'),
        Patch(facecolor='gray', edgecolor='black', label='Unknown Criticality'),
        Patch(facecolor='blue', edgecolor='black', label='External Dependency')
    ]
    plt.legend(handles=legend_elements, loc='upper right')

    # Show plot
    plt.title('Container Dependency Graph Grouped by Kubernetes Node')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

    # Save the figure
    output_filename = "container_dependency_graph_grouped.png"
    plt.savefig(output_filename, dpi=300, bbox_inches='tight')
    print(f"Graph saved as '{output_filename}'")

def main():
    # Select the consolidated JSON file
    consolidated_file = select_consolidated_file()
    if consolidated_file is None:
        return

    # Load consolidated data
    consolidated_data = load_consolidated_data(consolidated_file)

    # Visualize dependencies
    visualize_dependencies(consolidated_data)

if __name__ == '__main__':
    main()
